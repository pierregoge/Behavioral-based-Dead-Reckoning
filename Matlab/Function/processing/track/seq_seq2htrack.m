function [seq_out] = seq_seq2htrack(seq,decli)

%    T=htrack(A,M,s,fs)			% A and M are matrices
%	  or
%    T=htrack(A,M,s,fs,fc)		% A and M are matrices
%	  or
%    T=htrack(A,M,s)				% A and M are sensor structures
%	  or
%    T=htrack(A,M,s,fc)			% A and M are sensor structures
%    Simple horizontal dead-reckoned track (pseudo-track) estimation based on speed
%	  and heading. This differs from ptrack in that the animal's body angle is not
%	  considered. This makes it appropriate for animals that do not always move in the
%	  direction of their longitudinal axis.
%
%	  Inputs:
%    A is a nx3 acceleration matrix with columns [ax ay az]. Acceleration can
%		be in any consistent unit, e.g., g or m/s^2.
%    M is the magnetometer signal matrix, M=[mx,my,mz] in any consistent unit
%		(e.g., in uT or Gauss). A and M must have the same size (and so are both
%		measured at the same sampling rate).
%    s is the forward speed of the animal in m/s. s can be a single number meaning
%		that the animal is assumed to travel at a constant speed. s can also be a vector
%		with the same number of rows as M, e.g., generated by ocdr.
%    fs is the sampling rate of the sensor data in Hz (samples per second).
%	  fc (optional) specifies the cut-off frequency of a low-pass filter to
%		apply to A and M before computing heading. The filter cut-off frequency is
%	   in Hz. The filter length is 4*fs/fc. Filtering adds no group delay. If fc is
%		empty or not given, the default value of 0.2 Hz (i.e., a 5 second time constant) is used.
%
%    Returns:
%	  T is the estimated track in a local level frame. The track is defined as meters
%		of northward and eastward movement (termed 'northing' and 'easting', i.e,
%		T=[northing,easting]) relative to the animal's position at the start of the measurements
%		(which is defined as [0,0]). The track sampling rate is the same as for the input data and
%		so each row of T defines the track coordinates at times 0,1/fs,2/fs,... relative to the
%		start time of the measurements.
%
%	  Frame: This function assumes a [north,east,up] navigation frame and a
%	  [forward,right,up] local frame. Both A and M must be rotated if needed to match the
%	  animal's cardinal axes otherwise the track will not be meaningful. Use rotframe() to
%	  achieve this. Unless the local declination angle is also corrected with rotframe, the dead-
%	  reckoned track will use magnetic north rather than true north.
%
%    CAUTION: dead-reckoned tracks are usually very inaccurate. They are useful to get an
%	  idea of HOW animals move rather than WHERE they go. Few animals probably travel in exactly
%	  the direction of their longitudinal axis and anyway measuring the precise orientation of the
%	  longitudinal axis of a non-rigid animal is fraught with error. Moreover, if there is net flow
%	  in the medium, the animal will be advected by the flow in addition to its autonomous movement.
%	  For swimming animals this can lead to substantial errors. The forward speed is assumed to be
%	  with respect to the medium so the track derived here is NOT the 'track-made-good', i.e., the
%	  geographic movement of the animal. It estimates the movement of the animal with respect to the
%	  medium. There are numerous other sources of error so use at your own risk!
%
%	  Example:
%		v = ocdr(p,fs);
%		s = sqrt(max(1-v.^2,0));
%		T = htrack(A,M,s,fs)
% 	   returns: .
%
%    Valid: Matlab, Octave
%    markjohnson@st-andrews.ac.uk
%    Last modified: 2 Feb 2018 - added interpolation over NaN input values


if nargin < 2
    decli = 0;  %If no magnetic inclaison correction set to 0
else
    decli = decli.*pi/180; % Convert to radian
end

len = length(seq);

% if iscell(seq)
% for i=1:len
%         seq_b(i,:) = struct(seq{i});
%         seq_buf(i,:) = seq_b;
% 
% end
% clear seq
% seq = seq_buf;
% end

for i=1:len  % For loop for each input sequences
    
    if ~isstruct(seq(i))
            fprintf('seq_seq2track: Input need to be a structure or a cell\n');
            return
    else
        if ~strcmp(seq(i).type,'seq')
            fprintf('seq_seq2track: Input need to be a sequence of type SEQ \n') ;
            return
        end
    end
    
    if ~isfield(seq(i),'var')
        fprintf('seq_seq2track: Input structure need to have var field \n');
        return
    else
        if ~isfield(seq(i).var,'He')
            fprintf('seq_seq2track: Input var structure need to have heading field \n');
            return
        else
            if ~strcmp(seq(i).var.He.sampling,'regular')
                fprintf('seq_seq2track: Heading  must be a regularly sampled structure\n') ;
                return
            end
        end
        
        if ~isfield(seq(i).var,'S')
            fprintf('seq_seq2track: Input structure to have var field \n');
            return
        else
            if ~strcmp(seq(i).var.S.sampling,'regular')
                fprintf('seq_seq2track: Speed must be a regularly sampled structure\n') ;
                return
            end
        end
    end
    
    
    
    He = seq(i).var.He.data + decli ; % Store Heading data with magnetic declinaison offset correction
    S =  seq(i).var.S.data;  % Store Speed data
    srate = seq(i).var.S.sampling_rate;
    
    delX = nan(size(He(:,1),1),1);
    delY= nan(size(He(:,1),1),1);
    
    X= nan(size(He(:,1),1),1);
    Y= nan(size(He(:,1),1),1);
    
    
    S = S./srate;
    
    
    %% path reconstruction
    
    for j=1:size(He,1)
        
        if (He (j,1) < -pi)
            He(j,1) = He(j,1)+(2*pi);
        elseif  (He (j) > pi)
            He(j,1) = He(j,1)-(2*pi);
        end
    end
    
    delX(1,1)=0;
    delX(2:size(delX,1),1)=S(2:size(delX,1),1).*sin(He(1:size(delX,1)-1,1));
    delY(1,1)=0;
    delY(2:size(delY,1),1)=S(2:size(delX,1),1).*cos(He(1:size(delX,1)-1,1));
    
    X(1,1)=0;
    Y(1,1)=0;
    
    
    for j=2:size(X,1)
        X(j,1)=X(j-1,1)+delX(j,1);
        Y(j,1)=Y(j-1,1)+delY(j,1);
    end
    
    seq_out(i,1) = seq(i);
    seq_out(i,1).var.X.data = X;
    seq_out(i,1).var.X.sampling = 'regular';
    seq_out(i,1).var.X.sampling_rate = srate;
    seq_out(i,1).var.X.name = 'X';
    seq_out(i,1).var.X.full_name = 'Displacement X';
    
    seq_out(i,1).var.Y = seq_out(i).var.X;
    seq_out(i,1).var.Y.data = Y;
    seq_out(i,1).var.Y.name = 'Y';
    seq_out(i,1).var.Y.full_name = 'Displacement Y';
    
    
end

end

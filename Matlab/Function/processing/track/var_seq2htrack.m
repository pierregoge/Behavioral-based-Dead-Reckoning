function [seq] = seq_seq2htrack(seq,incli)

%    T=htrack(A,M,s,fs)			% A and M are matrices
%	  or
%    T=htrack(A,M,s,fs,fc)		% A and M are matrices
%	  or
%    T=htrack(A,M,s)				% A and M are sensor structures
%	  or
%    T=htrack(A,M,s,fc)			% A and M are sensor structures
%    Simple horizontal dead-reckoned track (pseudo-track) estimation based on speed
%	  and heading. This differs from ptrack in that the animal's body angle is not
%	  considered. This makes it appropriate for animals that do not always move in the
%	  direction of their longitudinal axis.
%
%	  Inputs:
%    A is a nx3 acceleration matrix with columns [ax ay az]. Acceleration can 
%		be in any consistent unit, e.g., g or m/s^2. 
%    M is the magnetometer signal matrix, M=[mx,my,mz] in any consistent unit
%		(e.g., in uT or Gauss). A and M must have the same size (and so are both 
%		measured at the same sampling rate).
%    s is the forward speed of the animal in m/s. s can be a single number meaning 
%		that the animal is assumed to travel at a constant speed. s can also be a vector
%		with the same number of rows as M, e.g., generated by ocdr.
%    fs is the sampling rate of the sensor data in Hz (samples per second).
%	  fc (optional) specifies the cut-off frequency of a low-pass filter to
%		apply to A and M before computing heading. The filter cut-off frequency is 
%	   in Hz. The filter length is 4*fs/fc. Filtering adds no group delay. If fc is 
%		empty or not given, the default value of 0.2 Hz (i.e., a 5 second time constant) is used.
%
%    Returns:
%	  T is the estimated track in a local level frame. The track is defined as meters
%		of northward and eastward movement (termed 'northing' and 'easting', i.e, 
%		T=[northing,easting]) relative to the animal's position at the start of the measurements 
%		(which is defined as [0,0]). The track sampling rate is the same as for the input data and
%		so each row of T defines the track coordinates at times 0,1/fs,2/fs,... relative to the
%		start time of the measurements.
%
%	  Frame: This function assumes a [north,east,up] navigation frame and a
%	  [forward,right,up] local frame. Both A and M must be rotated if needed to match the
%	  animal's cardinal axes otherwise the track will not be meaningful. Use rotframe() to
%	  achieve this. Unless the local declination angle is also corrected with rotframe, the dead-
%	  reckoned track will use magnetic north rather than true north.
%
%    CAUTION: dead-reckoned tracks are usually very inaccurate. They are useful to get an
%	  idea of HOW animals move rather than WHERE they go. Few animals probably travel in exactly
%	  the direction of their longitudinal axis and anyway measuring the precise orientation of the
%	  longitudinal axis of a non-rigid animal is fraught with error. Moreover, if there is net flow
%	  in the medium, the animal will be advected by the flow in addition to its autonomous movement.
%	  For swimming animals this can lead to substantial errors. The forward speed is assumed to be 
%	  with respect to the medium so the track derived here is NOT the 'track-made-good', i.e., the
%	  geographic movement of the animal. It estimates the movement of the animal with respect to the
%	  medium. There are numerous other sources of error so use at your own risk!
%
%	  Example:
%		v = ocdr(p,fs);
%		s = sqrt(max(1-v.^2,0));
%		T = htrack(A,M,s,fs)
% 	   returns: .
%
%    Valid: Matlab, Octave
%    markjohnson@st-andrews.ac.uk
%    Last modified: 2 Feb 2018 - added interpolation over NaN input values

if ~isstruct(seq)
    fprintf('seq_seq2track: Input need to be a structure \n');
    return
end

if ~isfield(seq.var)
    fprintf('seq_seq2track: Input structure to have var field \n');
    return
else
    if ~isfield(seq.var.)
    fprintf('seq_seq2track: Input structure to have var field \n');
    return
    end
    if ~isfield(seq.var)
    fprintf('seq_seq2track: Input structure to have var field \n');
    return
    end
    if ~isfield(seq.var)
    fprintf('seq_seq2track: Input structure to have var field \n');
    return
    end
    
end


end
